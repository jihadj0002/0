Script for analytics

<script>
document.addEventListener("DOMContentLoaded", () => {
  const buttons = document.querySelectorAll(".time-btn");

  const totalEl = document.getElementById("total-orders");
  const completedEl = document.getElementById("completed-orders");
  const pendingEl = document.getElementById("pending-orders");
  const chartLine = document.getElementById("order-chart-line");
  const rangeLabel = document.getElementById("analytics-range-label");
  
  const avgOrd = document.getElementById("avg-orders");
  const cSells = document.getElementById("chat-sales");
  const responseTime = document.getElementById("response-time");
  const salesChartLine = document.getElementById("sales-chart-line");
  const salesRangeLabel = document.getElementById("sales-range-label");


  // Default load (30D)
  loadOrderAnalytics("30D");

  buttons.forEach(btn => {
    btn.addEventListener("click", () => {
      buttons.forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      const range = btn.dataset.range;
      const labels = {
        "1D": "Last 24 Hours",
        "7D": "Last 7 Days",
        "30D": "Last 30 Days",
        "6M": "Last 6 Months"
      };
      rangeLabel.textContent = labels[range] || "Last 30 Days";

      loadOrderAnalytics(range);
    });
  });

  function loadOrderAnalytics(range) {
    // show loading placeholder
    totalEl.textContent = "...";
    completedEl.textContent = "...";
    pendingEl.textContent = "...";

    fetch(`{% url 'back:order_analytics' %}?range=${range}`)
      .then(res => {
        if (!res.ok) throw new Error("Network response was not ok");
        return res.json();
      })
      .then(data => {
        totalEl.textContent = data.total_orders ?? 0;
        completedEl.textContent = data.completed ?? 0;
        pendingEl.textContent = data.pending ?? 0;

        // Update sparkline
        const max = Math.max(...data.chart_data, 1);
        const scaleY = 100 / max;
        const points = data.chart_data
          .map((v, i) => `${i * 25},${100 - v * scaleY}`)
          .join(" ");
        chartLine.setAttribute("points", points);
      })
      .catch(err => {
        console.error("Error fetching analytics:", err);
        totalEl.textContent = "–";
        completedEl.textContent = "–";
        pendingEl.textContent = "–";
      });
  }
});
</script>


<script>

  // Sales & Revenue Analytics
document.addEventListener("DOMContentLoaded", () => {
  const salesButtons = document.querySelectorAll(".time-btn");
  const salesChartLine = document.getElementById("sales-chart-line");
  const salesRangeLabel = document.getElementById("sales-range-label");

  const avgOrdersEl = document.getElementById("avg-orders");
  const chatSalesEl = document.getElementById("chat-sales");
  const responseTimeEl = document.getElementById("response-time");

  // Default load (30D)
  loadSalesAnalytics("30D");

  // Handle time range clicks
  salesButtons.forEach(btn => {
    btn.addEventListener("click", () => {
      salesButtons.forEach(b => b.classList.remove("active"));
      btn.classList.add("active");

      const range = btn.textContent.trim(); // "1D", "7D", etc.
      const labels = {
        "1D": "Last 24 Hours",
        "7D": "Last 7 Days",
        "30D": "Last 30 Days",
        "6M": "Last 6 Months"
      };
      salesRangeLabel.textContent = labels[range] || "Last 30 Days";

      loadSalesAnalytics(range);
    });
  });

  function loadSalesAnalytics(range) {
    // Set placeholders while loading
    avgOrdersEl.textContent = "...";
    chatSalesEl.textContent = "...";
    responseTimeEl.textContent = "...";

    fetch(`{% url 'back:sales_analytics' %}?range=${range}`)
      .then(res => {
        if (!res.ok) throw new Error("Network response was not ok");
        return res.json();
      })
      .then(data => {
        // Update values from backend data
        const totalOrders = data.total_orders ?? 0;
        const completed = data.completed ?? 0;
        const pending = data.pending ?? 0;

        // Example placeholders — customize as needed
        avgOrdersEl.textContent = `$${totalOrders * 10}`; // fake avg revenue
        chatSalesEl.textContent = completed;              // completed orders
        responseTimeEl.textContent = pending + " mins";   // fake metric

        // Update sparkline dynamically
        const max = Math.max(...data.chart_data, 1);
        const scaleY = 100 / max;
        const points = data.chart_data
          .map((v, i) => `${i * 25},${100 - v * scaleY}`)
          .join(" ");
        salesChartLine.setAttribute("points", points);
      })
      .catch(err => {
        console.error("Error fetching sales analytics:", err);
        avgOrdersEl.textContent = "–";
        chatSalesEl.textContent = "–";
        responseTimeEl.textContent = "–";
      });
  }
});
</script>

Section for analytics


<!-- Analytics Section -->
<div class="layout-3cols" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(300px,1fr));gap:20px;margin-top:20px">
  <!-- Order Analytics -->
  <div class="panel analytics-panel">
    <div class="panel-header">
      <div>
        <h2>Order Analytics</h2>
        <div class="panel-sub" id="analytics-range-label">Last 30 Days</div>
      </div>
      <div class="time-range">
        <button class="time-btn active" data-range="1D">1D</button>
        <button class="time-btn" data-range="7D">7D</button>
        <button class="time-btn" data-range="30D">30D</button>
        <button class="time-btn" data-range="6M">6M</button>
      </div>
    </div>

    <div class="chart-wrap">
      <svg viewBox="0 0 300 120" class="sparkline" preserveAspectRatio="none" id="analytics-chart">
        <polyline fill="none" stroke="#22c55e" stroke-width="3" id="order-chart-line"
          points="0,90 30,80 60,70 90,50 120,55 150,45 180,30 210,35 240,25 270,20 300,15"/>
      </svg>
    </div>

    <div class="sales-stats">
      <div><div class="s-label">Total Orders</div><div class="s-value" id="total-orders">{{ total_orders }}</div></div>
      <div><div class="s-label">Completed</div><div class="s-value" id="completed-orders">{{ completed }}</div></div>
      <div><div class="s-label">Pending</div><div class="s-value" id="pending-orders">{{ pending }}</div></div>
    </div>
  </div>

  <!-- Message Analytics -->
  <div class="panel analytics-panel">
    <div class="panel-header">
      <div><h2>Message Status Analytics</h2><div class="panel-sub" id="msg-range-label">Overview</div></div>
      <div class="time-range">
        <button class="time-btn active">1D</button><button class="time-btn">7D</button>
        <button class="time-btn">30D</button><button class="time-btn">6M</button>
      </div>
    </div>
    <div class="chart-wrap">
      <svg viewBox="0 0 300 120" class="sparkline" preserveAspectRatio="none">
        <polyline fill="none" stroke="#f97316" stroke-width="3" id="msg-chart-line"
          points="0,100 30,90 60,70 90,80 120,50 150,40 180,60 210,30 240,35 270,20 300,25"/>
      </svg>
    </div>
    <div class="sales-stats">
      <div><div class="s-label">Total Messages</div><div class="s-value">3,242</div></div>
      <div><div class="s-label">Replied</div><div class="s-value">3,020</div></div>
      <div><div class="s-label">Pending</div><div class="s-value">222</div></div>
    </div>
  </div>

  <!-- Sales & Revenue -->
  <div class="panel analytics-panel">
    <div class="panel-header">
      <div><h2>Sales & Revenue</h2><div class="panel-sub" id="sales-range-label">Last 30 Days</div></div>
      <div class="time-range">
        <button class="time-btn active">1D</button><button class="time-btn">7D</button>
        <button class="time-btn">30D</button><button class="time-btn">6M</button>
      </div>
    </div>
    <div class="chart-wrap">
      <svg viewBox="0 0 300 120" class="sparkline" preserveAspectRatio="none">
        <polyline fill="none" stroke="#2563eb" stroke-width="3" id="sales-chart-line"
          points="0,90 30,70 60,85 90,60 120,80 150,55 180,65 210,40 240,60 270,30 300,20"/>
      </svg>
    </div>
    <div class="sales-stats">
      <div><div class="s-label">Avg Order</div><div class="s-value" id="avg-orders">${{total_sales}}</div></div>
      <div><div class="s-label">Chat Sales</div><div class="s-value" id="chat-sales">{{orders_count}}</div></div>
      <div><div class="s-label">Response Time</div><div class="s-value" id="response-time">1 Min</div></div>
    </div>
  </div>
</div>
Here is the views


@login_required
def dashboard(request):
    user = request.user
    
    total_sales = (
        Sale.objects.filter(user=user, status="completed")
        .aggregate(total=Sum("amount"))["total"]
        or 0
    )

    completed_sales = Sale.objects.filter(user=user, status="completed").count()
    total_conversations = Conversation.objects.filter(user=user).count()
    active_products = Product.objects.filter(user=user, stock_quantity__gt=0).count()

    orders_count = Sale.objects.filter(user=user).count()

    active_productss = Product.objects.filter(user=user, stock_quantity__gt=0)
    top_products = active_productss.order_by('-stock_quantity')[:3]
    
    conversion_rate = (
        round((completed_sales / total_conversations) * 100, 2)
        if total_conversations > 0
        else 0
    )

    context = {
        "total_sales": total_sales,
        "total_conversations": total_conversations,
        "conversion_rate": conversion_rate,
        "active_products": active_products,
        "top_products": top_products,
        "orders_count": orders_count,

    }
    return render(request, "back/dashboard.html", context)

# Dashboard Analytics View
@login_required
def get_order_analytics(request):
    user = request.user
    range_key = request.GET.get("range", "30D")
    # print(range_key)

    now = timezone.now()
    if range_key == "1D":
        start_date = now - timedelta(days=1)
    elif range_key == "7D":
        start_date = now - timedelta(days=7)
    elif range_key == "30D":
        start_date = now - timedelta(days=30)
    elif range_key == "6M":
        start_date = now - timedelta(days=180)
    else:
        start_date = now - timedelta(days=30)

    orders = Sale.objects.filter(user=user, created_at__gte=start_date)
    # print("Printing ")
    # print(orders)

    total_orders = orders.count()
    completed_orders = orders.filter(status="completed").count()
    pending_orders = orders.filter(status="pending").count()

    # For the small chart, simulate trend data (you can later replace this with real grouping)
    chart_data = list(range(0, total_orders if total_orders < 12 else 12))
    print(chart_data)

    return JsonResponse({
        "total_orders": total_orders,
        "completed": completed_orders,
        "pending": pending_orders,
        "chart_data": chart_data,
    })


# Dashboard Sales & Revenue Analytics View
@login_required
def get_sales_analytics(request):
    user = request.user
    range_key = request.GET.get("range", "30D")
    # print(range_key)

    now = timezone.now()
    if range_key == "1D":
        start_date = now - timedelta(days=1)
    elif range_key == "7D":
        start_date = now - timedelta(days=7)
    elif range_key == "30D":
        start_date = now - timedelta(days=30)
    elif range_key == "6M":
        start_date = now - timedelta(days=180)
    else:
        start_date = now - timedelta(days=30)

    orders = Sale.objects.filter(user=user, created_at__gte=start_date)
    # print("Printing ")
    # print(orders)

    total_orders = orders.count()
    completed_orders = orders.filter(status="completed").count()
    pending_orders = orders.filter(status="pending").count()

    # For the small chart, simulate trend data (you can later replace this with real grouping)
    chart_data = list(range(0, total_orders if total_orders < 12 else 12))
    print(chart_data)

    return JsonResponse({
        "total_orders": total_orders,
        "completed": completed_orders,
        "pending": pending_orders,
        "chart_data": chart_data,
    })


@login_required
def get_dashboard_metrics(request):
    """Return dashboard summary metrics as JSON.

    Metrics returned:
      - avg_order: average completed order amount in the selected range (string formatted)
      - chat_sales: number of completed sales in range (int)
      - response_time: approximate average response time as 'Hh Mm' based on matching sale times (or 'N/A')
      - total_messages: count of Conversation objects in range (int)
      - replied: conversations with non-empty response_text (int)
      - pending: conversations without a response_text (int)

    Notes/assumptions:
      - There is no explicit response timestamp on Conversation; to approximate response time we match
        Conversations to Sales by `customer_id` and compute the delta between conversation.timestamp and
        the earliest Sale.created_at that occurs after the conversation. If no matches found the response_time
        is returned as 'N/A'. This is a pragmatic heuristic given existing models.
    """
    user = request.user
    range_key = request.GET.get("range", "30D")

    now = timezone.now()
    if range_key == "1D":
        start_date = now - timedelta(days=1)
    elif range_key == "7D":
        start_date = now - timedelta(days=7)
    elif range_key == "30D":
        start_date = now - timedelta(days=30)
    elif range_key == "6M":
        start_date = now - timedelta(days=180)
    else:
        start_date = now - timedelta(days=30)

    # Sales-based metrics
    sales = Sale.objects.filter(user=user, created_at__gte=start_date)
    completed_sales_qs = sales.filter(status__iexact="completed")
    chat_sales = completed_sales_qs.count()
    avg_order_val = completed_sales_qs.aggregate(avg=Avg('amount'))['avg'] or 0

    # Conversation-based metrics
    conversations = Conversation.objects.filter(user=user, timestamp__gte=start_date)
    total_messages = conversations.count()
    replied_qs = conversations.filter(response_text__isnull=False).exclude(response_text="")
    replied = replied_qs.count()
    pending = total_messages - replied

    # Approximate response time by matching conversations to sales (by customer_id)
    response_deltas = []
    # iterate over replied conversations and try to find a sale occurring after the conversation timestamp
    for conv in replied_qs:
        # find earliest sale by the same customer that occurred after the conversation
        sale = (
            Sale.objects.filter(user=user, customer_id=conv.customer_id, created_at__gte=conv.timestamp)
            .order_by('created_at')
            .first()
        )
        if sale:
            delta = sale.created_at - conv.timestamp
            if delta.total_seconds() >= 0:
                response_deltas.append(delta)

    if response_deltas:
        avg_seconds = sum(d.total_seconds() for d in response_deltas) / len(response_deltas)
        hours = int(avg_seconds // 3600)
        minutes = int((avg_seconds % 3600) // 60)
        response_time_str = f"{hours}h {minutes}m"
    else:
        response_time_str = "N/A"

    # Format average order to two decimals with currency-like formatting
    try:
        avg_order_formatted = f"{float(avg_order_val):.2f}"
    except Exception:
        avg_order_formatted = str(avg_order_val)

    return JsonResponse({
        "avg_order": avg_order_formatted,
        "chat_sales": chat_sales,
        "response_time": response_time_str,
        "total_messages": total_messages,
        "replied": replied,
        "pending": pending,
    })


    Model for Chat data
    class Conversation(models.Model):
    PLATFORM_CHOICES = [
        ("messenger", "Messenger"),
        ("instagram", "Instagram"),
        ("whatsapp", "WhatsApp"),
        ("telegram", "Telegram"),
    ]
    
    GENDER_CHOICES = [
        ("male", "Male"),
        ("female", "Female"),
        ("unknown", "Unknown"),
    ]

    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name="conversations")
    platform = models.CharField(max_length=20, choices=PLATFORM_CHOICES)
    customer_id = models.CharField(max_length=255)  # external ID
    message_text = models.TextField(blank=True, null=True)
    

    # NEW COUNTERS
    bot_sent_count = models.IntegerField(default=0)
    bot_received_count = models.IntegerField(default=0)
    customer_sent_count = models.IntegerField(default=0)
    agent_sent_count = models.IntegerField(default=0)


    # -----------------------------------------------------
    # END EXTENDED VARIABLES
    # -----------------------------------------------------

    def __str__(self):
        return f"{self.platform} - {self.customer_id} ({self.timestamp})"


class Message(models.Model):
    conversation = models.ForeignKey(Conversation, on_delete=models.CASCADE, related_name="messages")
    
    SENDER_CHOICES = [
        ("customer", "Customer"),
        ("bot", "Bot"),
        ("agent", "Agent"),
    ]

    sender = models.CharField(max_length=20, choices=SENDER_CHOICES)
    text = models.TextField()
    timestamp = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.sender}: {self.text[:30]}"
